package domain

// NeuroNet
// Neuron
// Copyright © 2019 Eduard Sesigin. All rights reserved. Contacts: <claygod@yandex.ru>

/*
Neuron - нейрон.
Пока модель синхронная, т.к. предполагается не работа с реальным временем, а с поступающими пачками данными.
Эмулировать асинхронность можно, каждый раз, когда изменяется один из входных сигналов, делая полный расчёт
с использованием в остальных входах старых данных, т.е. идти по пути конечного автомата.

При принятии отрицательного решения по результатам входных сигналов всё равно рассылает
через аксон сигналы, но пустышки (для синхронизации).
При изменении  количества дендритов память должна обнуляться? Ведь дендриты могут и добавляться и отваливаться.
Можно юзать номера, и тогда удалённые номера будут пропускаться - это как-то можно реализовать.

Общая идея памяти (внутреннего состояния) нейрона: синапсы (дендриты и возможно аксон) смотрят на последовательности
и именно в них ищут закономерности. Сам же нейрон учитывает веса синапсов, корректирует их по результатам обратной связи
и возможно, пытается хранить паттерны, хотя это может оказаться нежелательным.

Клонирование может быть использовано как метод борьбы против переоптимизации, однако желательно, чтобы клонирование
не влекло за собой сильного понижения эффективности двух новых нейронов. На некоторых периодах (в конце) можно
блокировать возможность клонирования, пренебрегая небольшими рисками переоптимизации.

Протягивание новых связей к пред-предыдущим (или после-последующим) нейронам по результатам обучения с подкреплением
должно быть в отдельной фазе.
*/
type Neuron struct {
	id     uint64
	health int64 // возможно здоровье по сути зависит от наличия связей, и слабые связи или отмершие связи и есть показатель смерти нейрона

	dRepo DendritsRepoInterface // []DendriteInterface
	axon  AxonInterface
}

// func (n *Neuron) GetDendrite(fromId uint64) (*Dendrite, error) {
// 	return nil, nil //TODO:
// }

func (n *Neuron) AppendSignal(sig *Signal) { // в нейрон добавляем новый сигнал
	agg := n.getNewAggregator()
	for _, dID := range n.dRepo.List() {
		dendr, err := n.dRepo.Get(dID)
		if err != nil {
			//TODO: error to log
			continue
		}
		agg.Add(dID, dendr.AppendSignal(sig))
	}
	// рассылка результата через аксон
	newSig := sig.Clone(n, agg.Summary())
	if newSig.weight > 777 { //TODO: пороговое значение надо будет определять f(x) функцией, и оно будет динамическим
		n.axon.BroadcastTotal(newSig)
	} else {
		n.axon.BroadcastStochastic(newSig)
	}
}

func (n *Neuron) ForecastEstimate(weigth int64, sig *Signal) { // оценка совпадения прогноза и результата
}
func (n *Neuron) NextStep() { // переход к следующему шагу (списывание здоровья на шаг и т.п.)
}
func (n *Neuron) HealthCheck() int64 { // показатель здоровья
	return 1 //TODO:
}

func (n *Neuron) getNewAggregator() DendriteReactionsAggregateInterface {
	return nil //TODO: сделать генератор таких агрегаторов
}
